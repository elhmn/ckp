package store

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"time"

	"gopkg.in/yaml.v2"
)

const (
	autoGeneratedHeader = `## File generated by ckp. DO NOT EDIT
##
## author: elhmn
`
)

//Store defines the store.yaml file structure
type Store struct {
	Scripts []Script `json:"scripts,omitempty" yaml:"scripts,omitempty"`
}

var sensitiveWords = []string{"key",
	"secret",
	"auth",
	"creds",
	"credential",
	"token",
	"bearer"}

//Script defines the structure of an entry in the `Store`
type Script struct {
	ID           string    `json:"id,omitempty" yaml:"id,omitempty"`
	CreationTime time.Time `json:"creationtime,omitempty" yaml:"creationtime,omitempty"`
	UpdateTime   time.Time `json:"updatetime,omitempty" yaml:"updatetime,omitempty"`
	Comment      string    `json:"comment,omitempty" yaml:"comment,omitempty"`
	Solution     Solution  `json:"solution,omitempty" yaml:"solution,omitempty"`
	Code         Code      `json:"code,omitempty" yaml:"code,omitempty"`
}

func getField(field, value string) string {
	if value != "" {
		return fmt.Sprintf("%s: %s\n", field, value)
	}
	return ""
}

func (s Script) String() string {
	list := ""
	if s.Solution.Content != "" {
		list += getField("ID", s.ID)
		list += getField("CreationTime", s.CreationTime.Format(time.RFC1123))
		list += getField("UpdateTime", s.UpdateTime.Format(time.RFC1123))
		list += "  Type: Solution\n"
		list += getField("  Comment", s.Comment)
		list += getField("  Solution", s.Solution.Content)
	} else {
		list += getField("ID", s.ID)
		list += getField("CreationTime", s.CreationTime.Format(time.RFC1123))
		list += getField("UpdateTime", s.UpdateTime.Format(time.RFC1123))
		list += "  Type: Code\n"
		list += getField("  Alias", s.Code.Alias)
		list += getField("  Comment", s.Comment)
		list += getField("  Code", s.Code.Content)
	}

	return list
}

type Solution struct {
	Content string `json:"content,omitempty" yaml:"content,omitempty"`
}

type Code struct {
	Content string `json:"content,omitempty" yaml:"content,omitempty"`
	//Alias is the alias defined for the bash script in the rc file reference
	Alias string `json:"alias,omitempty" yaml:"alias,omitempty"`
}

//EntryAlreadyExist checks that a script entry of `id` already exist in the store
func (s *Store) EntryAlreadyExist(id string) bool {
	scripts := s.Scripts

	for _, script := range scripts {
		if script.ID == id {
			return true
		}
	}

	return false
}

//SaveStore saves the `Store` struct to the `filepath`
func (s *Store) SaveStore(filepath string) error {
	data, err := yaml.Marshal(s)
	if err != nil {
		return fmt.Errorf("failed to Marshal store struct: %s", err)
	}
	content := fmt.Sprintf("%s\n%s", autoGeneratedHeader, string(data))
	return ioutil.WriteFile(filepath, []byte(content), 0666)
}

//LoadStore loads store struct from solution repository
//Returns:
// - a pointer to the `Store` struct created
// - the content of the store file in `[]byte`
// - an error in case of failure
func LoadStore(filepath string) (*Store, []byte, error) {
	s := &Store{}

	if _, err := os.Stat(filepath); os.IsNotExist(err) {
		return s, []byte{}, nil
	}

	data, err := ioutil.ReadFile(filepath)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read file: %s", err)
	}

	err = yaml.Unmarshal(data, s)
	if err != nil {
		return s, data, fmt.Errorf("failed to unmarshal data: %s", err)
	}

	return s, data, nil
}

//GenereateIdempotentID generate a unique sha256
func GenereateIdempotentID(code, comment, alias, solution string) (string, error) {
	id := []byte(fmt.Sprintf("%s-%s-%s-%s", code, comment, alias, solution))
	hash := sha256.New()
	if _, err := hash.Write(id); err != nil {
		return "", err
	}
	return hex.EncodeToString(hash.Sum(nil)), nil
}

//HasSensitiveData checks if the `s` contains sensitive data
//
//Returns true and the keyword that was found in the string `s`
//was found
//Returns false when no keyword was found
func HasSensitiveData(s string) (bool, string) {
	s = strings.ToLower(s)

	for _, w := range sensitiveWords {
		strings.Contains(s, w)
		if strings.Contains(s, w) {
			return true, w
		}
	}

	return false, ""
}

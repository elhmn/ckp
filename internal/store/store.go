package store

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"os"
	"time"

	"gopkg.in/yaml.v2"
)

const (
	autoGeneratedHeader = `## File generated by ckp. DO NOT EDIT
##
## author: elhmn
`
)

//Store defines the store.yaml file structure
type Store struct {
	Scripts []Script `json:"scripts,omitempty" yaml:"scripts,omitempty"`
}

type Script struct {
	ID           string    `json:"id,omitempty" yaml:"id,omitempty"`
	CreationTime time.Time `json:"creationtime,omitempty" yaml:"creationtime,omitempty"`
	UpdateTime   time.Time `json:"updatetime,omitempty" yaml:"updatetime,omitempty"`
	Comment      string    `json:"comment,omitempty" yaml:"comment,omitempty"`
	Solution     Solution  `json:"solution,omitempty" yaml:"solution,omitempty"`
	Code         Code      `json:"code,omitempty" yaml:"code,omitempty"`
}

type Solution struct {
	Content  string `json:"content,omitempty" yaml:"content,omitempty"`
	FilePath string `json:"filepath,omitempty" yaml:"filepath,omitempty"`
}

type Code struct {
	Content string `json:"content,omitempty" yaml:"content,omitempty"`
	//Alias is the alias defined for the bash script in the rc file reference
	Alias string `json:"alias,omitempty" yaml:"alias,omitempty"`

	FilePath string `json:"filepath,omitempty" yaml:"filepath,omitempty"`
}

//EntryAlreadyExist checks that a script entry of `id` already exist in the store
func (s *Store) EntryAlreadyExist(id string) bool {
	scripts := s.Scripts

	for _, script := range scripts {
		if script.ID == id {
			return true
		}
	}

	return false
}

//SaveStore saves the `Store` struct to the `filepath`
func (s *Store) SaveStore(filepath string) error {
	data, err := yaml.Marshal(s)
	if err != nil {
		return fmt.Errorf("failed to Marshal store struct: %s", err)
	}
	content := fmt.Sprintf("%s\n%s", autoGeneratedHeader, string(data))
	return ioutil.WriteFile(filepath, []byte(content), 0666)
}

//LoadStore loads store struct from solution repository
//Returns:
// - a pointer to the `Store` struct created
// - the content of the store file in `[]byte`
// - an error in case of failure
func LoadStore(filepath string) (*Store, []byte, error) {
	s := &Store{}

	if _, err := os.Stat(filepath); os.IsNotExist(err) {
		return s, []byte{}, nil
	}

	data, err := ioutil.ReadFile(filepath)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to read file: %s", err)
	}

	err = yaml.Unmarshal(data, s)
	if err != nil {
		return s, data, fmt.Errorf("failed to unmarshal data: %s", err)
	}

	return s, data, nil
}

//GenereateIdempotentID generate a unique sha256
func GenereateIdempotentID(code, path, comment, alias, solution string) (string, error) {
	id := []byte(fmt.Sprintf("%s-%s-%s-%s-%s", code, path, comment, alias, solution))
	hash := sha256.New()
	if _, err := hash.Write(id); err != nil {
		return "", err
	}
	return hex.EncodeToString(hash.Sum(nil)), nil
}
